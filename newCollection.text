```

interface ArrayAccess<T> {
  delete(key: CollectionKey): void;
  get(key: CollectionKey): T | undefined;
  has(key: CollectionKey): boolean;
  set(key: CollectionKey, value: T): void;
}

interface Enumerable<K, T> {
  all(): T[];
  count(): number;
  isEmpty(): boolean;
  isNotEmpty(): boolean;
}

interface CanBeEscapedWhenCastToString {
  toString(): string;
}

type CollectionKey = string | number;

class Collection<T = never, K extends CollectionKey = number> implements ArrayAccess<T>, Iterable<T>, Enumerable<K, T>, CanBeEscapedWhenCastToString {
  protected items: Map<K, T>;

  constructor(items: Iterable<[K, T]> | T[] = []) {
    this.items = new Map<K, T>();

    if (Array.isArray(items)) {
      items.forEach((item, index) => this.items.set(index as unknown as K, item));
    } else {
      for (const [key, value] of items) {
        this.items.set(key, value);
      }
    }
  }

  /**
   * Retrieves all items as an array.
   */
  all(): T[] {
    return Array.from(this.items.values());
  }

  /**
   * Implements the Iterable interface.
   */
  [Symbol.iterator](): Iterator<T> {
    return this.items.values();
  }

  /**
   * Implements ArrayAccess.get
   */
  get(key: K): T | undefined {
    return this.items.get(key);
  }

  /**
   * Implements ArrayAccess.set
   */
  set(key: K, value: T): void {
    this.items.set(key, value);
  }

  /**
   * Implements ArrayAccess.has
   */
  has(key: K): boolean {
    return this.items.has(key);
  }

  /**
   * Implements ArrayAccess.delete
   */
  delete(key: K): void {
    this.items.delete(key);
  }

  /**
   * Converts the collection to a string.
   */
  toString(): string {
    return JSON.stringify(this.all());
  }

  /**
   * Retrieves the number of items in the collection.
   */
  count(): number {
    return this.items.size;
  }

  /**
   * Determines if the collection is empty.
   */
  isEmpty(): boolean {
    return this.items.size === 0;
  }

  /**
   * Plucks values from the collection based on the given key.
   *
   * @param key - The key or path to pluck.
   * @param keyProp - (Optional) The key to use for the returned object.
   * @returns A new Collection of plucked values or a Map if keyProp is provided.
   */
  pluck<K2 extends keyof T | string, V = any>(key: K2, keyProp?: K2): Collection<V, K2> | Map<any, V> {
    const plucked = pluck(this.all(), key, keyProp);
    if (keyProp) {
      return new Collection<V, K2>(Object.entries(plucked));
    }
    return new Collection<V>(plucked);
  }

  /**
   * Filters the collection using the provided callback.
   *
   * @param callback - A function to test each element.
   * @returns A new Collection with the filtered items.
   */
  filter(callback: (value: T, key: K) => boolean): Collection<T, K> {
    const filtered = Array.from(this.items.entries()).filter(([key, value]) => callback(value, key));
    return new Collection<T, K>(filtered);
  }

  /**
   * Maps the collection using the provided callback.
   *
   * @param callback - A function that produces an element of the new collection.
   * @returns A new Collection with the mapped items.
   */
  map<U>(callback: (value: T, key: K) => U): Collection<U, K> {
    const mapped = Array.from(this.items.entries()).map(([key, value]) => [key, callback(value, key)] as [K, U]);
    return new Collection<U, K>(mapped);
  }

  /**
   * Sorts the collection using a callback.
   *
   * @param compareFunction - Function used to determine the order of the elements.
   * @returns A new Collection with sorted items.
   */
  sort(compareFunction?: (a: T, b: T) => number): Collection<T, K> {
    const sorted = Array.from(this.items.entries());
    sorted.sort((a, b) => {
      if (compareFunction) {
        return compareFunction(a[1], b[1]);
      }
      if (a[1] < b[1]) return -1;
      if (a[1] > b[1]) return 1;
      return 0;
    });
    return new Collection<T, K>(sorted);
  }

  /**
   * Sorts the collection in descending order using a callback.
   *
   * @param compareFunction - Function used to determine the order of the elements.
   * @returns A new Collection with sorted items.
   */
  sortDesc(compareFunction?: (a: T, b: T) => number): Collection<T, K> {
    const sorted = Array.from(this.items.entries());
    sorted.sort((a, b) => {
      if (compareFunction) {
        return compareFunction(b[1], a[1]);
      }
      if (a[1] < b[1]) return 1;
      if (a[1] > b[1]) return -1;
      return 0;
    });
    return new Collection<T, K>(sorted);
  }

  /**
   * Groups the collection by a given key or callback.
   *
   * @param groupBy - The key or callback to group by.
   * @param preserveKeys - Whether to preserve keys in the grouped collections.
   * @returns A new Collection where keys are group identifiers and values are Collections.
   */
  groupBy<KGroup extends CollectionKey>(
    groupBy: (value: T, key: K) => KGroup | KGroup[],
    preserveKeys: boolean = false
  ): Collection<Collection<T, K>, KGroup> {
    const grouped = new Map<KGroup, Collection<T, K>>();
    for (const [key, value] of this.items.entries()) {
      const groupKeys = Array.isArray(groupBy(value, key)) ? groupBy(value, key) : [groupBy(value, key)];
      for (const groupKey of groupKeys) {
        if (!grouped.has(groupKey)) {
          grouped.set(groupKey, new Collection<T, K>());
        }
        grouped.get(groupKey)!.set(preserveKeys ? key : (grouped.get(groupKey)!.count() as unknown as K), value);
      }
    }
    return new Collection<Collection<T, K>, KGroup>(Array.from(grouped.entries()));
  }

  /**
   * Determines if the collection contains a given value.
   *
   * @param value - The value to search for or a callback function.
   * @returns True if the collection contains the value, false otherwise.
   */
  contains(value: T | ((value: T, key: K) => boolean)): boolean {
    if (typeof value === 'function') {
      for (const [key, val] of this.items.entries()) {
        if ((value as (value: T, key: K) => boolean)(val, key)) {
          return true;
        }
      }
      return false;
    }
    for (const val of this.items.values()) {
      if (val === value) return true;
    }
    return false;
  }

  /**
   * Determines if the collection contains exactly one item.
   *
   * @returns True if the collection has exactly one item, false otherwise.
   */
  containsOneItem(): boolean {
    return this.items.size === 1;
  }

  /**
   * Joins the collection items into a string using the specified glue.
   *
   * @param glue - The string to use as a separator.
   * @returns The joined string.
   */
  implode(glue: string): string {
    return Array.from(this.items.values()).join(glue);
  }

  /**
   * Merges the collection with the given items.
   *
   * @param items - The items to merge with.
   * @returns A new Collection with merged items.
   */
  merge<U>(items: Iterable<[K, U]> | U[]): Collection<T | U, K> {
    const merged = new Map<K, T | U>(this.items);
    if (Array.isArray(items)) {
      items.forEach((item, index) => merged.set(index as unknown as K, item));
    } else {
      for (const [key, value] of items) {
        merged.set(key, value);
      }
    }
    return new Collection<T | U, K>(Array.from(merged.entries()));
  }

  /**
   * Recursively merges the collection with the given items.
   *
   * @param items - The items to recursively merge with.
   * @returns A new Collection with recursively merged items.
   */
  mergeRecursive<U>(items: Iterable<[K, U]> | U[]): Collection<T | U, K> {
    const merged = new Map<K, any>(this.items);
    if (Array.isArray(items)) {
      items.forEach((item, index) => merged.set(index as unknown as K, item));
    } else {
      for (const [key, value] of items) {
        if (merged.has(key) && typeof merged.get(key) === 'object' && typeof value === 'object') {
          merged.set(key, new Collection([...merged.get(key), ...value]));
        } else {
          merged.set(key, value);
        }
      }
    }
    return new Collection<T | U, K>(Array.from(merged.entries()));
  }

  /**
   * Returns a new Collection with the items in reverse order.
   *
   * @returns A new Collection with reversed items.
   */
  reverse(): Collection<T, K> {
    const reversed = Array.from(this.items.entries()).reverse();
    return new Collection<T, K>(reversed);
  }

  /**
   * Retrieves a random item or a specified number of random items from the collection.
   *
   * @param count - The number of random items to retrieve.
   * @returns A single random item or a new Collection of random items.
   */
  random(count?: number): T | Collection<T, K> {
    const allItems = this.all();
    if (count === undefined) {
      return allItems[Math.floor(Math.random() * allItems.length)];
    }
    if (count <= 0) {
      return new Collection<T, K>();
    }
    const shuffled = shuffle(allItems);
    return new Collection<T, K>(shuffled.slice(0, count));
  }

  /**
   * Retrieves the first item in the collection.
   *
   * @param callback - (Optional) A callback to filter the first item.
   * @param defaultValue - (Optional) A default value if no item is found.
   * @returns The first item or the default value.
   */
  first(callback?: (value: T, key: K) => boolean, defaultValue?: T): T | undefined {
    if (callback) {
      for (const [key, value] of this.items.entries()) {
        if (callback(value, key)) {
          return value;
        }
      }
      return defaultValue;
    }
    return this.items.size > 0 ? this.items.values().next().value : defaultValue;
  }

  /**
   * Retrieves the last item in the collection.
   *
   * @param callback - (Optional) A callback to filter the last item.
   * @param defaultValue - (Optional) A default value if no item is found.
   * @returns The last item or the default value.
   */
  last(callback?: (value: T, key: K) => boolean, defaultValue?: T): T | undefined {
    if (callback) {
      const entries = Array.from(this.items.entries()).reverse();
      for (const [key, value] of entries) {
        if (callback(value, key)) {
          return value;
        }
      }
      return defaultValue;
    }
    const reversed = Array.from(this.items.values()).reverse();
    return reversed.length > 0 ? reversed[0] : defaultValue;
  }

  /**
   * Retrieves duplicate items from the collection.
   *
   * @param callback - (Optional) A callback to determine uniqueness.
   * @param strict - Whether to use strict comparison.
   * @returns A new Collection with duplicate items.
   */
  duplicates(callback?: (value: T, key: K) => any, strict: boolean = false): Collection<T, K> {
    const seen = new Set<any>();
    const duplicates = new Collection<T, K>();

    for (const [key, value] of this.items.entries()) {
      const identifier = callback ? callback(value, key) : value;
      if (seen.has(identifier)) {
        duplicates.set(key, value);
      } else {
        seen.add(identifier);
      }
    }

    return duplicates;
  }

  /**
   * Retrieves duplicate items using strict comparison.
   *
   * @param callback - (Optional) A callback to determine uniqueness.
   * @returns A new Collection with duplicate items.
   */
  duplicatesStrict(callback?: (value: T, key: K) => any): Collection<T, K> {
    return this.duplicates(callback, true);
  }

  /**
   * Chunks the collection into smaller collections of the specified size.
   *
   * @param size - The size of each chunk.
   * @returns A new Collection of chunked Collections.
   */
  chunk(size: number): Collection<Collection<T, K>, number> {
    const chunks: Collection<T, K>[] = [];
    const chunkArray: [K, T][] = [];

    let index = 0;
    for (const [key, value] of this.items.entries()) {
      chunkArray.push([key, value]);
      index++;
      if (index % size === 0) {
        chunks.push(new Collection<T, K>(chunkArray));
        chunkArray.length = 0; // Clear the array
      }
    }

    if (chunkArray.length > 0) {
      chunks.push(new Collection<T, K>(chunkArray));
    }

    return new Collection<Collection<T, K>, number>(chunks.map((chunk, idx) => [idx, chunk]));
  }

  /**
   * Creates a new collection consisting of every n-th element.
   *
   * @param step - The step interval.
   * @param offset - The starting offset.
   * @returns A new Collection with every n-th item.
   */
  nth(step: number, offset: number = 0): Collection<T, K> {
    const result: [K, T][] = [];
    let index = 0;
    for (const [key, value] of this.items.entries()) {
      if ((index - offset) % step === 0 && index >= offset) {
        result.push([key, value]);
      }
      index++;
    }
    return new Collection<T, K>(result);
  }

  /**
   * Creates a new collection consisting of the given number of items, repeating the original collection's items.
   *
   * @param count - The number of times to repeat the collection.
   * @returns A new Collection with repeated items.
   */
  multiply(count: number): Collection<T, K> {
    const multiplied: [K, T][] = [];
    for (let i = 0; i < count; i++) {
      for (const [key, value] of this.items.entries()) {
        multiplied.push([key, value]);
      }
    }
    return new Collection<T, K>(multiplied);
  }

  /**
   * Removes all items from the collection.
   *
   * @returns The emptied Collection.
   */
  clear(): Collection<T, K> {
    this.items.clear();
    return this;
  }

  /**
   * Retrieves a subset of the collection based on the specified keys.
   *
   * @param keys - The keys to retrieve.
   * @returns A new Collection containing only the specified keys.
   */
  only(...keys: K[]): Collection<T, K> {
    const filtered = Array.from(this.items.entries()).filter(([key]) => keys.includes(key));
    return new Collection<T, K>(filtered);
  }

  /**
   * Adds one or more items to the beginning of the collection.
   *
   * @param values - The values to prepend.
   * @returns The updated Collection.
   */
  prepend(...values: T[]): Collection<T, K> {
    const newItems = new Map<K, T>();
    let currentKey = 0 as unknown as K;

    values.forEach(value => {
      newItems.set(currentKey++, value);
    });

    for (const [key, value] of this.items.entries()) {
      newItems.set(key, value);
    }

    this.items = newItems;
    return this;
  }

  /**
   * Retrieves a flattened array of all items in the collection.
   *
   * @param depth - The maximum depth to flatten.
   * @returns A new Collection with flattened items.
   */
  flatten(depth: number = Infinity): Collection<any, K> {
    return new Collection<any, K>(flatten(this.all(), depth));
  }

  /**
   * Collapses a multi-dimensional collection into a single level collection.
   *
   * @returns A new Collection with collapsed items.
   */
  collapse(): Collection<any, K> {
    return new Collection<any, K>(collapse(this.all()));
  }

  /**
   * Creates a new collection by combining the keys of this collection with the values of another.
   *
   * @param values - The values to combine with.
   * @returns A new Collection of key-value pairs.
   */
  combine<U>(values: Iterable<U> | U[]): Collection<[T, U], number> {
    const combined: [T, U][] = [];
    const valueArray = Array.isArray(values) ? values : Array.from(values);
    const keys = this.all();
    for (let i = 0; i < keys.length; i++) {
      combined.push([keys[i], valueArray[i]]);
    }
    return new Collection<[T, U], number>(combined);
  }

  /**
   * Determines if the collection is not empty.
   *
   * @returns True if not empty, false otherwise.
   */
  isNotEmpty(): boolean {
    return !this.isEmpty();
  }

  /**
   * Counts the number of items in the collection by a given callback or key.
   *
   * @param iteratee - The callback or key to count by.
   * @returns A new Collection with counts.
   */
  countBy(iteratee?: (value: T, key: K) => string): Collection<number, string> {
    const counts: Map<string, number> = new Map();
    for (const [key, value] of this.items.entries()) {
      const group = iteratee ? iteratee(value, key) : String(value);
      counts.set(group, (counts.get(group) || 0) + 1);
    }
    return new Collection<number, string>(Array.from(counts.entries()));
  }

  /**
   * Returns a new collection with the items that do not pass the given truth test.
   *
   * @param callback - The callback function to filter items.
   * @returns A new Collection with rejected items.
   */
  reject(callback: (value: T, key: K) => boolean): Collection<T, K> {
    const rejected = Array.from(this.items.entries()).filter(([key, value]) => !callback(value, key));
    return new Collection<T, K>(rejected);
  }

  /**
   * Returns the sum of the values in the collection, optionally using a callback.
   *
   * @param callback - (Optional) A callback to transform items before summing.
   * @returns The sum of the collection's values.
   */
  sum(callback?: (value: T, key: K) => number): number {
    let total = 0;
    for (const [key, value] of this.items.entries()) {
      total += callback ? callback(value, key) : Number(value);
    }
    return total;
  }

  /**
   * Returns the average of the values in the collection, optionally using a callback.
   *
   * @param callback - (Optional) A callback to transform items before averaging.
   * @returns The average of the collection's values.
   */
  average(callback?: (value: T, key: K) => number): number {
    if (this.isEmpty()) return 0;
    return this.sum(callback) / this.count();
  }

  /**
   * Creates a new collection consisting of items matching a given predicate.
   *
   * @param predicate - The predicate to match items.
   * @returns A new Collection with matched items.
   */
  where(predicate: (value: T, key: K) => boolean): Collection<T, K> {
    return this.filter(predicate);
  }

  /**
   * Creates a new collection consisting of items not matching a given predicate.
   *
   * @param predicate - The predicate to filter out items.
   * @returns A new Collection with filtered items.
   */
  whereNot(predicate: (value: T, key: K) => boolean): Collection<T, K> {
    return this.reject(predicate);
  }

  /**
   * Retrieves the median value from the collection.
   *
   * @param callback - (Optional) A callback to transform items before finding the median.
   * @returns The median value or undefined if the collection is empty.
   */
  median(callback?: (value: T, key: K) => number): number | undefined {
    const values = callback ? this.map(callback).all() : this.all().map(v => Number(v));
    values.sort((a, b) => a - b);
    const count = values.length;
    if (count === 0) return undefined;
    const middle = Math.floor(count / 2);
    if (count % 2) {
      return values[middle];
    }
    return (values[middle - 1] + values[middle]) / 2;
  }

  /**
   * Retrieves the mode(s) of the collection.
   *
   * @param callback - (Optional) A callback to transform items before finding the mode.
   * @returns An array of the mode(s) or undefined if the collection is empty.
   */
  mode(callback?: (value: T, key: K) => any): any[] | undefined {
    if (this.isEmpty()) return undefined;
    const counts = new Map<any, number>();
    for (const [key, value] of this.items.entries()) {
      const identifier = callback ? callback(value, key) : value;
      counts.set(identifier, (counts.get(identifier) || 0) + 1);
    }
    const maxCount = Math.max(...counts.values());
    const modes = Array.from(counts.entries())
      .filter(([_, count]) => count === maxCount)
      .map(([key, _]) => key);
    return modes;
  }

  /**
   * Creates a new collection consisting of items after a given item.
   *
   * @param value - The value or predicate to find the item.
   * @param strict - Whether to use strict comparison.
   * @returns The item after the given item or undefined.
   */
  after(value: T | ((value: T, key: K) => boolean), strict: boolean = false): T | undefined {
    const entries = Array.from(this.items.entries());
    for (let i = 0; i < entries.length; i++) {
      const [key, val] = entries[i];
      const match = typeof value === 'function' ? value(val, key) : (strict ? val === value : val == value);
      if (match && i < entries.length - 1) {
        return entries[i + 1][1];
      }
    }
    return undefined;
  }

  /**
   * Creates a new collection consisting of items before a given item.
   *
   * @param value - The value or predicate to find the item.
   * @param strict - Whether to use strict comparison.
   * @returns The item before the given item or undefined.
   */
  before(value: T | ((value: T, key: K) => boolean), strict: boolean = false): T | undefined {
    const entries = Array.from(this.items.entries());
    for (let i = 1; i < entries.length; i++) {
      const [key, val] = entries[i];
      const match = typeof value === 'function' ? value(val, key) : (strict ? val === value : val == value);
      if (match) {
        return entries[i - 1][1];
      }
    }
    return undefined;
  }

  /**
   * Creates a new collection by zipping the collection with another iterable.
   *
   * @param sources - The iterables to zip with.
   * @returns A new Collection of zipped pairs.
   */
  zip<U>(...sources: Iterable<U>[]): Collection<[T, U], number> {
    const zipped: [T, U][] = [];
    const iterators = sources.map(source => source[Symbol.iterator]());

    for (const value of this.items.values()) {
      const zippedPair: [T, U] = [value, undefined as unknown as U];
      sources.forEach((source, index) => {
        const result = iterators[index].next();
        if (!result.done) {
          zippedPair[1] = result.value;
        }
      });
      zipped.push(zippedPair);
    }

    return new Collection<[T, U], number>(zipped.map((pair, idx) => [idx, pair]));
  }

  /**
   * Retrieves the first item in the collection that matches the given predicate or value.
   *
   * @param value - The value or predicate to match.
   * @param strict - Whether to use strict comparison.
   * @returns The first matching item or undefined.
   */
  find(value: T | ((value: T, key: K) => boolean), strict: boolean = false): T | undefined {
    for (const [key, val] of this.items.entries()) {
      const match = typeof value === 'function' ? value(val, key) : (strict ? val === value : val == value);
      if (match) {
        return val;
      }
    }
    return undefined;
  }

  /**
   * Slices the collection.
   *
   * @param offset - The starting index.
   * @param length - The number of items to include.
   * @returns A new Collection with the sliced items.
   */
  slice(offset: number, length?: number): Collection<T, K> {
    const slicedEntries = Array.from(this.items.entries()).slice(offset, length !== undefined ? offset + length : undefined);
    return new Collection<T, K>(slicedEntries);
  }

  /**
   * Transforms the collection by applying a callback to each item.
   *
   * @param callback - The callback to apply.
   * @returns The transformed Collection.
   */
  transform(callback: (value: T, key: K) => T): Collection<T, K> {
    for (const [key, value] of this.items.entries()) {
      this.items.set(key, callback(value, key));
    }
    return this;
  }

  /**
   * Checks if the collection uses the provided value as a callable.
   *
   * @param value - The value to check.
   * @returns True if callable, false otherwise.
   */
  protected useAsCallable(value: any): value is Function {
    return useAsCallable(value);
  }

  /**
   * Retrieves a value or a callback.
   *
   * @param value - The value or callback to retrieve.
   * @returns The resolved value or callback.
   */
  protected valueRetriever<U>(value: ((value: T, key: K) => U) | string | null): ((value: T, key: K) => U) {
    if (this.useAsCallable(value)) {
      return value;
    }

    if (typeof value === 'string') {
      return (item: T) => data_get(item, value, undefined);
    }

    throw new Error('Invalid value retriever');
  }
}
```
